#!/usr/bin/perl

use strict;
use RPC::XML;
require RPC::XML::Client;
use IO::Uncompress::Gunzip qw(gunzip $GunzipError) ;
use IMDB::Film;
use XML::Simple;
use Data::Dumper;

my $app_name="TVShow2iTunes";
my $ua = LWP::UserAgent->new();
my $useragent=$ua->agent($app_name);
my $cli;
my $videoSRT;
my $convert=undef;
if(scalar(@ARGV)>0){
	#Log into subtitles to get the token
	my $login=login();
	
	foreach my $filename (@ARGV){
		#getting the filename
		my $fname=substr($filename, rindex($filename,"/")+1,length($filename)-rindex($filename,"/")-1);
		print STDERR "Searching for $fname\n";
		
		#getSubtitle
		GetSubtitles($filename,$login);
		
		##Getting the metadata########
		getMetaDataIMDBAPI($videoSRT->{IDMovieImdb}->value);
		#getMetaDataIMDBPERL($imdb);
		#getMetaDataOpen($imdb);
		#############################
		
		#Converting to m4v
		Recoding($filename);

	}
	logout($login);
}else{
	print "ERROR :: Missing arguments\n";
}
sub login{
	$cli = RPC::XML::Client->new('http://api.opensubtitles.org/xml-rpc');
	my $log;
	if($cli->send_request('ServerInfo')){
		$log=$cli->send_request('LogIn',("","","eng"),$ua->agent($app_name));
		# Login failed?
	    if ( ! defined($log) )
	    {
	        print STDERR "ERROR :: ";
	        print $RPC::XML::ERROR, "\n";
	        exit(0);
	    }
	}
	return($log);
}
sub logout{
	my $log=shift;
	$log=$cli->send_request('LogOut',$log->{token}->value);
	return;
}
sub Recoding{
	my $inputfilename=shift;
	my $outputfilename = substr $inputfilename, 0, rindex( $inputfilename, q{.} );
	$outputfilename.=".m4v";
	$outputfilename=quotemeta($outputfilename);
	
	my ($videoS,$audio)=getStreams($inputfilename);

	my $movieName=$videoSRT->{MovieName}->value;
	my $tvShow;
	my $tvChapter;
	my $tvSeason;
	
	#Notifing to the user;
	`bin/growlnotify -m "Converting  $movieName"`;
	$convert=1;
	$inputfilename=quotemeta $inputfilename;
	my $ac3file="$inputfilename.ac3";
	my $h264file="$inputfilename.h264";
	my $aacfile="$inputfilename.aac";
	
	my $Video_cmd="bin/mkvextract tracks $inputfilename ".$videoS->{id}.":$h264file &>/dev/null";
	my $audio_cmd="bin/mkvextract tracks $inputfilename ".$audio->{id}.":$ac3file &>/dev/null";
	my $audio_cmd_convert="bin/mencoder $inputfilename -aid 0 -ovc copy -oac faac -faacopts br=160:mpeg=4:object=2 -channels $audio->{Channel} -srate $audio->{Sampling_rate}000 -of rawaudio -o $aacfile &>/dev/null" if ($convert);
	my $m4v_cmd ="bin/mp4box -add $inputfilename\.h264:lang=$audio->{language} -add $inputfilename\.ac3:lang=$audio->{language} -add $inputfilename\." .  $videoSRT->{ISO639}->value . "." . $videoSRT->{SubFormat}->value .":lang=" . $videoSRT->{LanguageName}->value.":group=2:disable -add $inputfilename\.aac:lang=".$audio->{language}." -disable 2 -group-add trackId=2:trackId=4 -keepall -new -fps $videoS->{Frate} $outputfilename &>/dev/null";
	#print "$Video_cmd\n$audio_cmd\n$audio_cmd_convert\n$m4v_cmd\n";
	#print "FILE :: To create $outputfilename\t(" . $videoSRT->{MovieName}->value . ")\n";
	
	print "LOG :: Extracting H.264 file\n";
	system($Video_cmd);
	print "LOG :: Extracting Audio file\n";
	system($audio_cmd);
	print "LOG :: Extracting Audio ACC file\n";
	system($audio_cmd_convert);
	print "LOG :: Creation $outputfilename\n";
	system($m4v_cmd);
	print "LOG :: Done !\n";
	system("rm $ac3file");
	system("rm $h264file");
	system("rm $aacfile");
}
sub getStreams{
	my $inputfilename=shift;
	$inputfilename=quotemeta($inputfilename);
	my $log_file="/tmp/.$$\.log" . ".log";
	system("bin/mediainfo $inputfilename --LogFile=$log_file --Output=XML 0 1 2 > /dev/null");
	my $Sampling_rate;
	my $audio;	
	my $videoS;	
	my $type;
	my $id;
	my $Bdepth;
	my $language;
	my $Codec_ID;
	my $Channel;
	open(XML,$log_file) || die "$! ($log_file)";
	while(my $line=<XML>){
		chomp($line);
		if($line =~ /^<\/track>/){
			if($type and $id and $Bdepth and $language and $Codec_ID and $Sampling_rate and $Channel){
				#print "//\nType $type\nID $id\nBdepth $Bdepth\nLangage $language\nCodec_ID $Codec_ID\nSampling_rate $Sampling_rate\nChannel $Channel\n//\n";
				$audio->{type}=$type;
				$audio->{Bdepth}=$Bdepth;
				$audio->{Codec_ID}=$Codec_ID;
				$audio->{language}=$language;
				$audio->{Channel}=$Channel;
				$audio->{id}=$id;
				$audio->{Sampling_rate}=$Sampling_rate;
			}
			next;
		}
		elsif($line =~ /^<track type="Audio"/){
			$type="Audio";
		}
		elsif($line =~ /<ID>(\d+)<\/ID>/ ){
			$id=$1;
		}elsif($line =~ /<Bit_depth>(\d+) bits<\/Bit_depth>/ ){
			$Bdepth=$1;
		}elsif($line =~ /<Language>(\w+)<\/Language>/ ){
			$language=$1;
		}elsif($line =~ /<Codec_ID>(.+)<\/Codec_ID>/){
			$Codec_ID=$1;
		}elsif($line =~ /<Sampling_rate>(\d+)\.0 KHz<\/Sampling_rate>/){
			$Sampling_rate=$1;
		}elsif($line =~ /<Channel_s_>(\d+) channels<\/Channel_s_>/){
			$Channel=$1;
		}elsif($line =~ /<track type="Video">/ ){
			next;
		}
	}
	close XML;
	my $type;
	my $id;
	my $FProfile;
	my $Frate;
	open(XML,$log_file) || die "$!";
	while(my $line=<XML>){
		chomp($line);
		if($line =~ /^<\/track>/){
			if($type and $id and $FProfile and $Frate){
				# print "//\nType $type\nID $id\n$FProfile $FProfile\nFrate $Frate\n//\n";
				$videoS->{type}=$type;
				$videoS->{FProfile}=$FProfile;
				$videoS->{Frate}=$Frate;
				$videoS->{id}=$id;
				return($videoS,$audio);
			}
			next;
		}
		elsif($line =~ /^<track type="Video"/){
			$type="Video";
		}
		elsif($line =~ /<ID>(\d+)<\/ID>/ ){
			$id=$1;
		}elsif($line =~ /<Format_profile>(.+)<\/Format_profile>/ ){
			$FProfile=$1;
		}elsif($line =~ /<Frame_rate>(.+) fps<\/Frame_rate>/ ){
			$Frate=$1;
		}elsif($line =~ /<track type="Audio">/ ){
			next;
		}
	}
	close XML;	
}
sub getMetaDataOpen{
	my $imdb=shift;
	
	if($imdb>1){
		my $cli = RPC::XML::Client->new('http://api.opensubtitles.org/xml-rpc');
		if($cli->send_request('ServerInfo')){
			my $log=$cli->send_request('LogIn',("","","eng"),$ua->agent($app_name));
			my $resultIMDB =$cli->send_request('GetIMDBMovieDetails',$log->{token}->value,$imdb);
			print Dumper($resultIMDB);
		}
	}
}
sub getMetaDataIMDBAPI{
	my $imdb=shift;
	
	if($imdb>1){
		my $url="http://www.imdbapi.com/?i=tt$imdb&t=&r=XML&plot=full";
		my $tmp_file="/tmp/\.$imdb\_$$.xml";
		my $response = $ua->get($url,':content_file' => $tmp_file);
		if(-s $tmp_file >26){
			my $data = XMLin($tmp_file);
			my @artworkName=split(/\//,$data->{movie}->{poster});
			my $artworkFile="/tmp/".$artworkName[$#artworkName];
			my $response = $ua->get( $data->{movie}->{poster},':content_file' => $artworkFile);
		         die "Can't get " . $artworkName[$#artworkName]."  -- ", $response->status_line unless $response->is_success;
			#print STDERR "ArtWork: $artworkFile\n";
			$videoSRT->{cover}=$artworkFile;
			#print "=============================================================================\n";
		}
	}else{
		print STDERR "ERROR :: Wrong IMDBiD\n";
		exit;
	}
}
sub getMetaDataIMDBPERL{
	my $imdb=shift;
	if($imdb>1){
		print "IMDB :: $imdb\n";
    	my $imdbObj = new IMDB::Film(crit => $imdb);
        if($imdbObj->status) {
                print "Title: ".$imdbObj->title()."\n";
                print "Year: ".$imdbObj->year()."\n";
                print "Plot Symmary: ".$imdbObj->plot()."\n";
                print "Cover: ".$imdbObj->poster()."\n";
				print "Summary: " . $imdbObj->storyline() . "\n";
				#print "TVShow: " . $imdbObj->episodeof()->[0] . "\n";
				#print Dumper($imdbObj->episodeof());
				# foreach $b (keys %{$imdbObj->episodeof()}){
				# 	print "TVShow: " . $b ."\n";
				# }
				# foreach my $a (keys %{$imdbObj}){
				#  	print $a ."\t" . $imdbObj->$a ."\n";
				# }
        } else {
                print "Something wrong: ".$imdbObj->error;
        }
	}
}
sub GetSubtitles{

	my $filename=shift;
	my $log=shift;
	my $size = -s $filename;
	my $hash=OpenSubtitlesHash("$filename");
	
	my $result =$cli->send_request('SearchSubtitles',$log->{token}->value,[{ sublanguageid => "spa,eng",moviehash => $hash, moviebytesize => $size}]);
	my $rootname=substr($filename, rindex($filename,"/")+1,length($filename)-rindex($filename,"/")-1);
	# Stop if xml-rpc request failed
	if ( ! defined($result) )
	{
	    print "--> Search failed!\n";
	    print $RPC::XML::ERROR, "\n";
	    exit(0);
	}
	else
	{
		print "LOG :: Searching subtitles\n";
		my $imdb;
		my $array_ref;
		foreach my $subtitle_info ( @{$result->{data}} )
		{
			foreach my $a (keys %{$subtitle_info}){
				$videoSRT->{$a}=$subtitle_info->{$a};
			}
	    	my $gzfilename=$filename. "." .  $subtitle_info->{ISO639}->value . "." . $subtitle_info->{SubFormat}->value .".gz";
			my $srtfilename=$filename. "." .  $subtitle_info->{ISO639}->value . "." . $subtitle_info->{SubFormat}->value;

			my $response = $ua->get( $subtitle_info->{SubDownloadLink}->value,':content_file' => $gzfilename);
			         die "Can't get " . $subtitle_info->{SubDownloadLink}->value."  -- ", $response->status_line unless $response->is_success;

			my $status = gunzip $gzfilename => $srtfilename or die "gunzip failed: $GunzipError\n";
			$imdb=$subtitle_info->{IDMovieImdb}->value;
			unlink($gzfilename);
			
		}
		return($imdb) if($imdb>1);
	}

}
sub OpenSubtitlesHash {
        my $filename = shift or die("Need video filename");

        open my $handle, "<", $filename or die $!;
        binmode $handle;

        my $fsize = -s $filename;

        my $hash = [$fsize & 0xFFFF, ($fsize >> 16) & 0xFFFF, 0, 0];

        $hash = AddUINT64($hash, ReadUINT64($handle)) for (1..8192);

    my $offset = $fsize - 65536;
    seek($handle, $offset > 0 ? $offset : 0, 0) or die $!;

    $hash = AddUINT64($hash, ReadUINT64($handle)) for (1..8192);

    close $handle or die $!;
    return UINT64FormatHex($hash);
}
sub ReadUINT64 {
        read($_[0], my $u, 8);
        return [unpack("vvvv", $u)];
}
sub AddUINT64 {
    my $o = [0,0,0,0];
    my $carry = 0;
    for my $i (0..3) {
        if (($_[0]->[$i] + $_[1]->[$i] + $carry) > 0xffff ) {
                        $o->[$i] += ($_[0]->[$i] + $_[1]->[$i] + $carry) & 0xffff;
                        $carry = 1;
                } else {
                        $o->[$i] += ($_[0]->[$i] + $_[1]->[$i] + $carry);
                        $carry = 0;
                }
        }
    return $o;
}
sub UINT64FormatHex {
    return sprintf("%04x%04x%04x%04x", $_[0]->[3], $_[0]->[2], $_[0]->[1], $_[0]->[0]);
}
