#!/usr/bin/perl

use strict;
use RPC::XML;
require RPC::XML::Client;
use IO::Uncompress::Gunzip qw(gunzip $GunzipError) ;
use IMDB::Film;
use XML::Simple;
use Data::Dumper;

my $app_name="TVShow2iTunes";
my $ua = LWP::UserAgent->new();
my $useragent=$ua->agent($app_name);
my $cli;
my $video;
if(scalar(@ARGV)>0){
	#Log into subtitles to get the token
	my $login=login();
	
	foreach my $filename (@ARGV){
		#getting the filename
		my $fname=substr($filename, rindex($filename,"/")+1,length($filename)-rindex($filename,"/")-1);
		print STDERR "Searching for $fname\n";
		#Notifing to the user;
		
		#getSubtitle
		my $imdb=GetSubtitles($filename,$login);
		
		##Getting the metadata########
		getMetaDataIMDBAPI($imdb);
		#getMetaDataIMDBPERL($imdb);
		#getMetaDataOpen($imdb);
		#############################
		
		#Converting to m4v
		Recoding($filename);

	}
	logout($login);
}else{
	print "ERROR :: Missing arguments\n";
}
sub login{
	$cli = RPC::XML::Client->new('http://api.opensubtitles.org/xml-rpc');
	my $log;
	if($cli->send_request('ServerInfo')){
		$log=$cli->send_request('LogIn',("","","eng"),$ua->agent($app_name));
		# Login failed?
	    if ( ! defined($log) )
	    {
	        print STDERR "ERROR :: ";
	        print $RPC::XML::ERROR, "\n";
	        exit(0);
	    }
	}
	return($log);
}
sub logout{
	my $log=shift;
	$log=$cli->send_request('LogOut',$log->{token}->value);
	return;
}
sub Recoding{
	my $inputfilename=shift;
	my $outputfilename = substr $inputfilename, 0, rindex( $inputfilename, q{.} );
	$outputfilename.=".m4v";
	#./SublerCLI -l Spanish -n Spanish -i ~/Proyectos/Organizer/Data/misfits.s01e03.720p.hdtv.x264-bia.mkv -o ~/Proyectos/Organizer/Data/misfits.s01e03.720p.hdtv.x264-bia.m4v 
	#-t "{TV Show:Misfits}{TV Episode:3}{TV Season:1}{HD Video:1}{Name:Chapter Three}{Artwork:/Users/eandres/Proyectos/Organizer/Scripts/Misfitss01.jpg}{Media Kind:TV Show}" 
	#./SublerCLI -i ~/Proyectos/Organizer/Scripts/misfits.s01e03.720p.hdtv.x264-bia.es.srt -o ~/Proyectos/Organizer/Data/misfits.s01e03.720p.hdtv.x264-bia.m4v
	my $movieName=$video->{MovieName}->value;
	my $tvShow;
	my $tvChapter;
	my $tvSeason;
	
	`bin/growlnotify -m "Converting  $movieName"`;
	
	my $cmd="bin/SublerCLI -l " . $video->{LanguageName}->value ." -n ". $video->{LanguageName}->value ." -i ".$inputfilename ." -o ". $outputfilename . " -t \"{TV Show:".$movieName."}{TV Episode:3}{TV Season:1}{HD Video:0}{Name:". $movieName."}{Artwork:".$video->{cover}."}{Media Kind:TV Show}\" -O";
	print "\n". $cmd ."\n";
	#print "FILE :: To create $outputfilename\t(" . $video->{MovieName}->value . ")\n";
	system($cmd);
}
sub getMetaDataOpen{
	my $imdb=shift;
	
	if($imdb>1){
		my $cli = RPC::XML::Client->new('http://api.opensubtitles.org/xml-rpc');
		if($cli->send_request('ServerInfo')){
			my $log=$cli->send_request('LogIn',("","","eng"),$ua->agent($app_name));
			my $resultIMDB =$cli->send_request('GetIMDBMovieDetails',$log->{token}->value,$imdb);
			print Dumper($resultIMDB);
		}
	}
}
sub getMetaDataIMDBAPI{
	my $imdb=shift;
	
	if($imdb>1){
		my $url="http://www.imdbapi.com/?i=tt$imdb&t=&r=XML&plot=full";
		my $tmp_file="/tmp/\.$imdb\_$$.xml";
		my $response = $ua->get($url,':content_file' => $tmp_file);
		if(-s $tmp_file >26){
			my $data = XMLin($tmp_file);
			#print Dumper($data);
			# print $data->{movie}->{plot} ."\n";
			foreach my $a (keys %{$data->{movie}}){
				#print $a ."\t". $data->{movie}->{$a} ."\n";
			}
			my @artworkName=split(/\//,$data->{movie}->{poster});
			my $artworkFile="/tmp/".$artworkName[$#artworkName];
			my $response = $ua->get( $data->{movie}->{poster},':content_file' => $artworkFile);
		         die "Can't get " . $artworkName[$#artworkName]."  -- ", $response->status_line unless $response->is_success;
			print STDERR "ArtWork: $artworkFile\n";
			$video->{cover}=$artworkFile;
			# 'released' => 'N/A',
			#         'genre' => 'Comedy, Drama, Fantasy, Sci-Fi',
			#         'rating' => '8.0',
			#         'director' => 'Tom Harper',
			#         'writer' => 'Howard Overman',
			#         'runtime' => 'N/A',
			#         'plot' => 'Alisha reveals her feelings for Curtis. They aim for a relationship but must be careful,given her powers. Shygirl 18 proves to be Sally,girl-friend of the dead Tony,who is suspicious about his disappearance though Simon booked a one-way flight in Tony\'s name,using his visa card,to imply he had left the country.Workmen are digging the ground where the bodies were buried so the group have to move them into another hole. They are almost caught by Sally but Curtis saves the situation by turning back time and the operation is successfully completed.',
			#         'title' => 'Episode #1.3',
			#         'id' => 'tt1548850',
			#         'votes' => '111',
			#         'year' => '2009',
			#         'rated' => 'N/A',
			#         'poster' => 'http://ia.media-imdb.com/images/M/MV5BMjAxNTk2MjM2NF5BMl5BanBnXkFtZTcwMjQyNDMyNA@@._V1_SX320.jpg',
			#         'actors' => 'Antonia Thomas, Lauren Socha, Iwan Rheon, Robert Sheehan'
			print "=============================================================================\n";
		}
	}else{
		print STDERR "ERROR :: Wrong IMDBiD\n";
		exit;
	}
}
sub getMetaDataIMDBPERL{
	my $imdb=shift;
	if($imdb>1){
		print "IMDB :: $imdb\n";
    	my $imdbObj = new IMDB::Film(crit => $imdb);
        if($imdbObj->status) {
                print "Title: ".$imdbObj->title()."\n";
                print "Year: ".$imdbObj->year()."\n";
                print "Plot Symmary: ".$imdbObj->plot()."\n";
                print "Cover: ".$imdbObj->poster()."\n";
				print "Summary: " . $imdbObj->storyline() . "\n";
				#print "TVShow: " . $imdbObj->episodeof()->[0] . "\n";
				#print Dumper($imdbObj->episodeof());
				# foreach $b (keys %{$imdbObj->episodeof()}){
				# 	print "TVShow: " . $b ."\n";
				# }
				# foreach my $a (keys %{$imdbObj}){
				#  	print $a ."\t" . $imdbObj->$a ."\n";
				# }
        } else {
                print "Something wrong: ".$imdbObj->error;
        }
	}
}
sub GetSubtitles{

	my $filename=shift;
	my $log=shift;
	my $size = -s $filename;
	my $hash=OpenSubtitlesHash("$filename");
	
	my $result =$cli->send_request('SearchSubtitles',$log->{token}->value,[{ sublanguageid => "spa,eng",moviehash => $hash, moviebytesize => $size}]);
	my $rootname=substr($filename, rindex($filename,"/")+1,length($filename)-rindex($filename,"/")-1);
	# Stop if xml-rpc request failed
	if ( ! defined($result) )
	{
	    print "--> Search failed!\n";
	    print $RPC::XML::ERROR, "\n";
	    exit(0);
	}
	else
	{
		print "=============================================================================\n";
		my $imdb;
		my $array_ref;
		foreach my $subtitle_info ( @{$result->{data}} )
		{
			foreach my $a (keys %{$subtitle_info}){
			 	#print $a ."\t". $subtitle_info->{$a}->value ."\n";
				$video->{$a}=$subtitle_info->{$a};
			}
			print "MovieName\t".$subtitle_info->{MovieName}->value ."\n";
			print "LanguageName\t".$subtitle_info->{LanguageName}->value ."\n";
			print "SubDownloadLink\t".$subtitle_info->{SubDownloadLink}->value . "\n";
    
	    	my $gzfilename=$filename. "." .  $subtitle_info->{ISO639}->value . "." . $subtitle_info->{SubFormat}->value .".gz";
			my $srtfilename=$filename. "." .  $subtitle_info->{ISO639}->value . "." . $subtitle_info->{SubFormat}->value;

			my $response = $ua->get( $subtitle_info->{SubDownloadLink}->value,':content_file' => $gzfilename);
			         die "Can't get " . $subtitle_info->{SubDownloadLink}->value."  -- ", $response->status_line unless $response->is_success;

			my $status = gunzip $gzfilename => $srtfilename or die "gunzip failed: $GunzipError\n";
			$imdb=$subtitle_info->{IDMovieImdb}->value;
			unlink($gzfilename);
			
		}
		#$IDSubtitleFiles->(int 1952647922);
		#$array_ref = [ 1952647922,1952647923];
		#print \$IDSubtitleFiles;
		#my $Download=$cli->('DownloadSubtitles',$log->{token}->value,$array_ref);

		return($imdb) if($imdb>1);
	}

}
sub OpenSubtitlesHash {
        my $filename = shift or die("Need video filename");

        open my $handle, "<", $filename or die $!;
        binmode $handle;

        my $fsize = -s $filename;

        my $hash = [$fsize & 0xFFFF, ($fsize >> 16) & 0xFFFF, 0, 0];

        $hash = AddUINT64($hash, ReadUINT64($handle)) for (1..8192);

    my $offset = $fsize - 65536;
    seek($handle, $offset > 0 ? $offset : 0, 0) or die $!;

    $hash = AddUINT64($hash, ReadUINT64($handle)) for (1..8192);

    close $handle or die $!;
    return UINT64FormatHex($hash);
}
sub ReadUINT64 {
        read($_[0], my $u, 8);
        return [unpack("vvvv", $u)];
}
sub AddUINT64 {
    my $o = [0,0,0,0];
    my $carry = 0;
    for my $i (0..3) {
        if (($_[0]->[$i] + $_[1]->[$i] + $carry) > 0xffff ) {
                        $o->[$i] += ($_[0]->[$i] + $_[1]->[$i] + $carry) & 0xffff;
                        $carry = 1;
                } else {
                        $o->[$i] += ($_[0]->[$i] + $_[1]->[$i] + $carry);
                        $carry = 0;
                }
        }
    return $o;
}
sub UINT64FormatHex {
    return sprintf("%04x%04x%04x%04x", $_[0]->[3], $_[0]->[2], $_[0]->[1], $_[0]->[0]);
}
